#version 450
// Kernel group size.
layout (local_size_x = 16, local_size_y = 16) in;



struct VoxelData {
    vec4 color;
    vec4 normal;
};
struct DirectionalLight {
    vec4 color;
    vec4 direction;
};

// Output image.
layout (set = 0, binding = 0, rgba8) uniform image2D outImg;

// Shader basic data.
layout (set = 0, binding = 1) uniform UniformBuffer {
    uint lightCount;
    uint gridDim;
    uvec2 _padding_;

    uvec2 screenResolution;
    vec2 screenWorldSize;

    vec4 cameraPosition;
    vec4 cameraForward;
    vec4 cameraUp;
    vec4 cameraRight;

    vec3 gridWorldCoords;
    float gridWorldSize;
    
    vec4 backgroundColor;
    DirectionalLight lights[8]; // maximum 8 lights for now
} uniformBuffer;

// Voxels
layout (std140, set = 0, binding = 2) readonly buffer VoxelDataBuffer {
    VoxelData data[];
} voxelDataBuffer;
// We need the std430 layout here so that the array stride is 4 bytes.
// The std140 layout would round it up to 16 bytes.
layout (std430, set = 0, binding = 3) readonly buffer VoxelMaskBuffer {
    uint mask[];
} voxelMaskBuffer;
// This buffer contains the partial counts of the voxel mask,
// i.e. partialCount[i] contains the number of 1 bits in the voxel mask
// between uint '0' and uint 'i' (both included).
// This buffer's size is the same as the mask buffer. 
layout (std430, set = 0, binding = 4) readonly buffer VoxelMaskPCBuffer {
    uint partialCount[];
} voxelMaskPCBuffer;

// Assumes x fits on 8 bits
uint split_by_3(uint x)
{
    x &= 0xFF;                     // 0000 0000 0000 0000 1111 1111
    x = (x | (x << 8)) & 0x00F00F; // 0000 0000 1111 0000 0000 1111
    x = (x | (x << 4)) & 0x0c30c3; // 0000 1100 0011 0000 1100 0011
    x = (x | (x << 2)) & 0x249249; // 0010 0100 1001 0010 0100 1001
    return x;
}

#define INDEX_MORTON(cell) (        \
    split_by_3((cell).x) |          \
    (split_by_3((cell).y) << 1) |   \
    (split_by_3((cell).z) << 2)     \
)     
#define INDEX3D(cell, dim) ((cell).z + (dim) * (cell).y + (dim) * (dim) * (cell).x)
#define INDEX(cell, dim) INDEX3D(cell, dim)

#define BIT_SET(x, bit) ((x) & (1 << (bit)))


// returns 0 if x < 0
//         1 if x > 0
//        (0.5 if x == 0)
float sign01(float x)
{
    return 2.0f * sign(x) - 1.0f;
}

float max3_(float a, float b, float c)
{
    return max(a, max(b, c));
}

float min3_(float a, float b, float c)
{
    return min(a, min(b, c));
}

bool has_voxel(uint index)
{
    // The voxels.mask is an array of uints,
    // each 32 bits wide == (1 << 5) bits wide).
    uint mask = voxelMaskBuffer.mask[index >> 5];
    return bool(BIT_SET(mask, index & 0x1F));
}

uint voxel_position(uint index)
{
    // We have to count the number of 1s in the mask,
    // strictly before the bit at 'index'.
    uint q = index >> 5;
    uint r = index & ((1 << 5) - 1);
    
    uint pos = 0;
    if (q > 0) {
        pos += voxelMaskPCBuffer.partialCount[q-1];
    }
    if (r > 0) {
        pos += bitCount(voxelMaskBuffer.mask[q] & ((1 << r) - 1));
    }
    return pos;
}

// A negative value means no intersection.
// A positive value t means the intersection point is at orig + t * dir.
float raygrid_intersect(vec3 orig, vec3 dir)
{
    vec3 invDir = 1.0f / dir;
    vec3 t_0 = (uniformBuffer.gridWorldCoords - orig) * invDir; 
    vec3 t_1 = (uniformBuffer.gridWorldCoords + uniformBuffer.gridWorldSize - orig) * invDir;
    
#define SWAP(a, b) { float tmp = a; a = b; b = tmp; }
    // We chech invDir.x < 0f rather than t_0.x > t_1.x (almost equivalent),
    // because of numerical stability issues when dir.x == 0f.
    // See the comment in raytrace() for an explanation.
    if (invDir.x < 0.0f) SWAP(t_0.x, t_1.x)
    if (invDir.y < 0.0f) SWAP(t_0.y, t_1.y)
    if (invDir.z < 0.0f) SWAP(t_0.z, t_1.z)
#undef SWAP

    float t_enter = max3_(t_0.x, t_0.y, t_0.z);
    float t_leave = min3_(t_1.x, t_1.y, t_1.z);

    // no intersection
    if (t_enter > t_leave || t_leave < 0.0f) {
        return -1.0f;
    }
    // the origin is out of the grid.
    if (t_enter > 0.0f) {
        return t_enter;
    }
    // the origin is in the grid.
    else {
        return 0.0f;
    }
}

bool dda(vec3 orig, vec3 dir, out float out_t, out uvec3 out_cell)
{
    float cellSize = uniformBuffer.gridWorldSize / uniformBuffer.gridDim;
    vec3 normOrig = (orig - uniformBuffer.gridWorldCoords) / cellSize;
    vec3 invDir = 1.0f / dir;

    // Differential cell/time values.
    vec3 d_t = cellSize * abs(invDir);
    ivec3 d_cell = ivec3(sign(dir));
    // make sure d_cell != 0, to avoid any infite loop.
    bvec3 mask = equal(d_cell, vec3(0, 0, 0));
    d_cell += ivec3(mask);

    // Current cell/time values.
    float curr_t = 0;
    ivec3 curr_cell = ivec3(floor(normOrig));
    
    // Next crossing times.
    // For numerical stability reasons we check the sign of invDir rather than dir.
    // If e.g. dir.x == -0f, then dir.x >= 0f is true but 1f / dir.x = -inf,
    // which is not what we want (when dir.x >= 0f, we want 1f / dir.x >= 0f); 
    vec3 nextCross_t = curr_cell - normOrig;
    if (invDir.x >= 0.0f) nextCross_t.x += 1.0f;
    if (invDir.y >= 0.0f) nextCross_t.y += 1.0f;
    if (invDir.z >= 0.0f) nextCross_t.z += 1.0f;
    nextCross_t *= cellSize * invDir;

    while (true) {
        // Out of grid
        if (curr_cell.x < 0 || curr_cell.x >= uniformBuffer.gridDim || 
            curr_cell.y < 0 || curr_cell.y >= uniformBuffer.gridDim || 
            curr_cell.z < 0 || curr_cell.z >= uniformBuffer.gridDim) {
            return false;
        }

        // Is there a voxel here ?
        uint index = INDEX(curr_cell, uniformBuffer.gridDim); 
        if (has_voxel(index)) {
            out_t = curr_t;
            out_cell = uvec3(curr_cell);
            return true;
        }

        // x
        if (nextCross_t.x <= nextCross_t.y && nextCross_t.x <= nextCross_t.z) {
            curr_t = nextCross_t.x;
            nextCross_t.x += d_t.x;
            curr_cell.x += d_cell.x;
        }   
        // y
        else if (nextCross_t.y <= nextCross_t.z) {
            curr_t = nextCross_t.y;
            nextCross_t.y += d_t.y;
            curr_cell.y += d_cell.y;
        }
        // z
        else {
            curr_t = nextCross_t.z;
            nextCross_t.z += d_t.z;
            curr_cell.z += d_cell.z;
        }
    }
}


vec4 shade(uint cell_index, vec3 hit_pos, vec3 ray_dir)
{
    VoxelData voxel = voxelDataBuffer.data[voxel_position(cell_index)];

    vec4 diffuse = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    for (uint i = 0; i < uniformBuffer.lightCount; i++) {
        DirectionalLight light = uniformBuffer.lights[i];
        
        // Check the light illuminates the voxel
        float dummy_t;
        vec3 dummy_cell;
        bool hit = dda(hit_pos, -light.direction.xyz, dummy_t, dummy_cell);
        if (!hit) {
            // Add the light contribution
            float intensity = max(dot(-light.direction, voxel.normal), 0.0f);
            diffuse += intensity * light.color;
        }
    }

    vec4 ambient = vec4(0.05f, 0.05f, 0.05f, 1.0f);

    return voxel.color * (ambient + diffuse);
}

vec4 raytrace(vec3 orig, vec3 dir)
{
    float t;
    uvec3 cell;
    bool hit = dda(orig, dir, t, cell);
    if (hit) {
        uint index = INDEX(cell, uniformBuffer.gridDim);
        return shade(index, orig + (t - 0.0001f) * dir, dir);
    }
    else {
        return uniformBuffer.backgroundColor;
    }
}


void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x < uniformBuffer.screenResolution.x && 
        gid.y < uniformBuffer.screenResolution.y) {
    
        // Compute the ray direction
        float dx = 2.0f * (gid.x / float(uniformBuffer.screenResolution.x)) - 1.0f;
        float dy = 2.0f * (gid.y / float(uniformBuffer.screenResolution.y)) - 1.0f;
        vec3 dir = normalize(
            uniformBuffer.cameraForward.xyz +
            dx * uniformBuffer.screenWorldSize.x * uniformBuffer.cameraRight.xyz +
            dy * uniformBuffer.screenWorldSize.y * uniformBuffer.cameraUp.xyz);

        float start_t = raygrid_intersect(uniformBuffer.cameraPosition.xyz, dir);
        vec4 color = uniformBuffer.backgroundColor;
        if (start_t >= 0.0f) {
            // Project the origin onto the grid, along the ray direction.
            vec3 projected_orig = uniformBuffer.cameraPosition.xyz + start_t * dir + 0.001f * dir;
            color = raytrace(projected_orig, dir);
        }
        imageStore(outImg, ivec2(gid), color);
    }
}