#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

// Include other files  
//#define DEBUG_LOG
#include "utils.comp"
#include "voxelizer/inputs.comp"
#include "tape.comp"


void update_mask_pc(uint node, uvec3 cell)
{
    if (cell == uvec3(0, 0, 0)) {
        uint node_pos = params_buf.levels[lvl].node_ofs +
           node * NODE_SIZE(lvl);     

        uint pc = 0;
        uint i = 0; 
        while (i < (dim*dim*dim)/32) {
            pc += bitCount(node_buf.data[node_pos + NODE_OFS_INTERIOR_MASK(lvl) + i]);
            node_buf.data[node_pos + NODE_OFS_INTERIOR_MASK_PC(lvl) + i] = pc;
            i++;
        }
    }
}


// returns true if the cell is an interior node
bool update_interior_mask(uint node, uvec3 cell)
{
    uint lvl = params_buf.level;
    
    // Set the child interior node bit    
    uint node_pos = params_buf.levels[lvl].node_ofs +
        node * NODE_SIZE(lvl);     
    atomicOr(node_buf.data[node_pos + NODE_OFS_INTERIOR_MASK(lvl) + q], 1 << r);

    return true;
}

void set_basic_cell_info(uint node, uvec3 cell, uint child)
{
    // get the parent coordinates
    uint node_pos = params_buf.levels[lvl].node_ofs + 
        node * NODE_SIZE(lvl);
    uvec3 node_coords;
    node_coords.x = node_buf.data[node_pos + NODE_OFS_COORDS(lvl) + 0];
    node_coords.y = node_buf.data[node_pos + NODE_OFS_COORDS(lvl) + 1];
    node_coords.z = node_buf.data[node_pos + NODE_OFS_COORDS(lvl) + 2];
    
    // set the child coordinates
    uint child_pos = params_buf.levels[lvl+1].node_ofs + 
        child * NODE_SIZE(lvl+1);
    node_buf.data[child_pos + NODE_OFS_COORDS(lvl+1) + 0] = 
        params_buf.levels[lvl].dim * node_coords.x + cell.x;
    node_buf.data[child_pos + NODE_OFS_COORDS(lvl+1) + 1] = 
        params_buf.levels[lvl].dim * node_coords.y + cell.y;
    node_buf.data[child_pos + NODE_OFS_COORDS(lvl+1) + 2] = 
        params_buf.levels[lvl].dim * node_coords.z + cell.z;
}

void set_child_list_entry(uint node, uvec3 cell, uint child)
{
    // set the child id in the parent child list
    uint node_pos = params_buf.levels[lvl].node_ofs +
        node * NODE_SIZE(lvl);
    uint entry_pos = params_buf.levels[lvl].child_ofs +
        node * CL_SIZE(lvl);

    uint cell_index = INDEX3D(cell, params_buf.levels[lvl].dim);
    uint q = cell_index >> 5;
    uint r = cell_index & ((1 << 5) - 1);

    if (q > 0) {
        entry_pos += node_buf.data[node_pos + NODE_OFS_INTERIOR_MASK_PC(level) + (q-1)];
    }
    if (r > 0) {
        uint mask = node_buf.data[node_pos + NODE_OFS_INTERIOR_MASK(level) + q];
        entry_pos += bitCount(mask & ((1 << r) - 1));
    }
    child_buf.data[entry_pos] = child;
}

bool has_interior_node(uint node, uvec3 cell)
{
    uint lvl = params_buf.level;

    uint cell_index = INDEX3D(cell, params_buf.levels[lvl].dim);
    uint q = cell_index >> 5;
    uint r = cell_index & ((1 << 5) - 1);
    
    uint node_pos = params_buf.levels[lvl].node_ofs +
        node * NODE_SIZE(lvl);     
    uint mask = node_buf.data[node_pos + NODE_OFS_INTERIOR_MASK(lvl) + q];
    return bool(mask & (1 << r));
}

void setup_child(uint node, uvec3 cell)
{
    uint cell_index = INDEX3D(cell, dim);
    uint q = cell_index >> 5;
    uint r = cell_index & ((1 << 5) - 1);
    
    uint node_pos = params_buf.levels[lvl].node_ofs +
        node * NODE_SIZE(lvl);     

    uint child = atomicAdd(params_buf.child_id_counter, 1);
    set_basic_cell_info(node, cell, child);
    set_child_list_entry(node, cell, child);
}

void main()
{
    uvec3 cell = gl_GlobalInvocationID.xyz % params_buf.levels[params_buf.level].dim;
    uint node = gl_GlobalInvocationID.x / params_buf.levels[params_buf.level].dim;
    
    update_mask_pc(node, cell);
    if (has_interior_node(node, cell)) {
        setup_child(node, cell);
    }
}
