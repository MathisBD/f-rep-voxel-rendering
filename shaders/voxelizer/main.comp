#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_atomic_float : require 

// Include other files  
#define DEBUG_LOG 
#include "utils.comp"
#include "voxelizer/inputs.comp"
#include "node.comp"
#include "tape/tape.comp"
#include "tape/point.comp"
#include "tape/interval.comp"
#include "tape/shorten.comp"


#define LVL params_buf.level
#define DIM params_buf.levels[params_buf.level].dim

void set_leaf_bit(uint node, uvec3 cell, bool set)
{
    uint cell_index = INDEX3D(cell, DIM);
    uint mask_pos = params_buf.levels[LVL].node_ofs +
        node * NODE_SIZE(LVL) + NODE_OFS_LEAF_MASK(LVL);     

    if (set) { 
        BITSET_ATOMIC_SET(node_buf.data, mask_pos, cell_index); 
    }
    else { 
        BITSET_ATOMIC_CLEAR(node_buf.data, mask_pos, cell_index); 
    }
}

void set_interior_bit(uint node, uvec3 cell, bool set)
{
    uint cell_index = INDEX3D(cell, DIM);
    uint mask_pos = params_buf.levels[LVL].node_ofs +
        node * NODE_SIZE(LVL) + NODE_OFS_INTERIOR_MASK(LVL);     

    if (set) { 
        BITSET_ATOMIC_SET(node_buf.data, mask_pos, cell_index); 
    }
    else { 
        BITSET_ATOMIC_CLEAR(node_buf.data, mask_pos, cell_index); 
    }
}

void set_child_list_entry(uint node, uvec3 cell, uint child)
{
    // set the child id in the parent child list
    uint child_list_pos = params_buf.levels[LVL].node_ofs +
        node * NODE_SIZE(LVL) +
        NODE_OFS_CHILD_LIST(LVL);

    uint cell_index = INDEX3D(cell, DIM);
    node_buf.data[child_list_pos + cell_index] = child;
}

void set_child_coords(uint child, uvec3 coords)
{
    uint coords_pos = params_buf.levels[LVL+1].node_ofs +
        child * NODE_SIZE(LVL+1) + NODE_OFS_COORDS(LVL+1);
    node_buf.data[coords_pos + 0] = coords.x;
    node_buf.data[coords_pos + 1] = coords.y;
    node_buf.data[coords_pos + 2] = coords.z;
}

void set_child_tape_idx(uint child, uint tape_idx)
{
    uint idx_pos = params_buf.levels[LVL+1].node_ofs +
        child * NODE_SIZE(LVL+1) + NODE_OFS_TAPE_IDX(LVL+1);
    node_buf.data[idx_pos] = tape_idx;
}

void voxelize_point(uint node, uvec3 cell)
{
    uint tape = node_get_tape_index(node, LVL);
    uvec3 child_coords = node_get_coords(node, LVL) * DIM + cell;
    vec3 child_pos = params_buf.grid_world_pos + 
        child_coords * params_buf.levels[LVL].cell_size;
    
    float density = tape_eval_point(tape, child_pos);
    set_leaf_bit(node, cell, density < 0.0f);
}

void voxelize_interval(uint node, uvec3 cell, bool shorten)
{
    uint tape = node_get_tape_index(node, LVL);
    uvec3 child_coords = node_get_coords(node, LVL) * DIM + cell;
    vec3 child_pos = params_buf.grid_world_pos + 
        child_coords * params_buf.levels[LVL].cell_size;
    
    if (shorten) {
        uint mm_array[MM_ARRAY_SIZE];
        uint mm_size;
        Interval density = tape_eval_interval(tape, 
            child_pos, child_pos + params_buf.levels[LVL].cell_size,
            mm_array, mm_size);
        // Empty node
        if (density.low > 0) {
            set_leaf_bit(node, cell, false);
            set_interior_bit(node, cell, false);
            return;
        }  
        // Leaf node
        if (density.high < 0) {
            set_leaf_bit(node, cell, true);
            set_interior_bit(node, cell, false);
            return;
        }
        // Ambiguous node
        set_leaf_bit(node, cell, false);
        set_interior_bit(node, cell, true);
        uint child = atomicAdd(counters_buf.child_count, 1);
        
        // Collect some stats
        uint child_tape = tape_shorten(tape, mm_array, mm_size);
        if (child_tape != tape) {
            uint child_size = tape_read_size(child_tape);
            //atomicAdd(stats_buf.tape_count[LVL+1], 1);
            //atomicAdd(stats_buf.tape_size_sum[LVL+1], child_size);
            atomicMax(stats_buf.max_tape_size[LVL+1], child_size);
        }

        set_child_list_entry(node, cell, child);
        set_child_coords(child, child_coords);
        set_child_tape_idx(child, child_tape);
    }
    else {
        Interval density = tape_eval_interval(tape, 
            child_pos, child_pos + params_buf.levels[LVL].cell_size);
        // Empty node
        if (density.low > 0) {
            set_leaf_bit(node, cell, false);
            set_interior_bit(node, cell, false);
            return;
        }  
        // Leaf node
        if (density.high < 0) {
            set_leaf_bit(node, cell, true);
            set_interior_bit(node, cell, false);
            return;
        }
        // Ambiguous node
        set_leaf_bit(node, cell, false);
        set_interior_bit(node, cell, true);
        uint child = atomicAdd(counters_buf.child_count, 1);
        set_child_list_entry(node, cell, child);
        set_child_coords(child, child_coords);
        set_child_tape_idx(child, tape);
    }  
}


// The first stage only updates the leaf and interior masks.
// All the other book-keeping operations are performed in the second stage. 
void main()
{ 
    LOG1("c=%f\n", c);

    uvec3 cell = gl_GlobalInvocationID.xyz % DIM;
    uint node = gl_GlobalInvocationID.x / DIM;

    if (LVL == params_buf.level_count - 1) {
        voxelize_point(node, cell);
    }
    else {
        bool shorten = LVL < (params_buf.level_count - 2);
        //bool shorten = true;
        voxelize_interval(node, cell, shorten);
    }
} 