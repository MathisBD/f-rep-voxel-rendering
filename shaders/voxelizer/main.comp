#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_debug_printf : enable

// Include other files  
//#define DEBUG_LOG 
#include "utils.comp"
#include "voxelizer/inputs.comp"
#include "node.comp"
#include "tape/tape.comp"
#include "tape/point.comp"
#include "tape/interval.comp"
#include "tape/shorten.comp"


#define LVL params_buf.level
#define DIM params_buf.levels[params_buf.level].dim

void set_leaf_bit(uint node, uvec3 cell, bool set)
{
    uint cell_index = INDEX3D(cell, DIM);
    uint q = cell_index >> 5;
    uint r = cell_index & ((1 << 5) - 1);
    
    uint node_pos = params_buf.levels[LVL].node_ofs +
        node * NODE_SIZE(LVL);     

    if (set) {
        atomicOr(node_buf.data[node_pos + NODE_OFS_LEAF_MASK(LVL) + q], 1 << r);
    }
    else {
        atomicAnd(node_buf.data[node_pos + NODE_OFS_LEAF_MASK(LVL) + q], ~(1 << r));
    }
}

void set_interior_bit(uint node, uvec3 cell, bool set)
{
    uint cell_index = INDEX3D(cell, DIM);
    uint q = cell_index >> 5;
    uint r = cell_index & ((1 << 5) - 1);
    
    uint node_pos = params_buf.levels[LVL].node_ofs +
        node * NODE_SIZE(LVL);     

    if (set) {
        atomicOr(node_buf.data[node_pos + NODE_OFS_INTERIOR_MASK(LVL) + q], 1 << r);
    }
    else {
        atomicAnd(node_buf.data[node_pos + NODE_OFS_INTERIOR_MASK(LVL) + q], ~(1 << r));
    }
}

void set_child_list_entry(uint node, uvec3 cell, uint child)
{
    // set the child id in the parent child list
    uint child_list_pos = params_buf.levels[LVL].node_ofs +
        node * NODE_SIZE(LVL) +
        NODE_OFS_CHILD_LIST(LVL);

    uint cell_index = INDEX3D(cell, DIM);
    node_buf.data[child_list_pos + cell_index] = child;
}

void set_child_coords(uint child, uvec3 coords)
{
    uint coords_pos = params_buf.levels[LVL+1].node_ofs +
        child * NODE_SIZE(LVL+1) + NODE_OFS_COORDS(LVL+1);
    node_buf.data[coords_pos + 0] = coords.x;
    node_buf.data[coords_pos + 1] = coords.y;
    node_buf.data[coords_pos + 2] = coords.z;
}

void set_child_tape_idx(uint child, uint tape_idx)
{
    uint idx_pos = params_buf.levels[LVL+1].node_ofs +
        child * NODE_SIZE(LVL+1) + NODE_OFS_TAPE_IDX(LVL+1);
    node_buf.data[idx_pos] = tape_idx;
}

void voxelize(uint node, uvec3 cell)
{
    // node coordinates
    uint coords_pos = params_buf.levels[LVL].node_ofs +
        node * NODE_SIZE(LVL) + NODE_OFS_COORDS(LVL);
    uvec3 coords = uvec3(
        node_buf.data[coords_pos + 0],
        node_buf.data[coords_pos + 1],
        node_buf.data[coords_pos + 2]);
    uvec3 child_coords = coords * DIM + cell;
    vec3 child_pos = params_buf.grid_world_pos + 
        child_coords * params_buf.levels[LVL].cell_size;
    
    // node tape index
    uint idx_pos = params_buf.levels[LVL].node_ofs +
        node * NODE_SIZE(LVL) + NODE_OFS_TAPE_IDX(LVL);
    uint tape = node_buf.data[idx_pos];

    // Point evaluation 
    if (LVL == params_buf.level_count - 1) {
        float density = tape_eval_point(tape, child_pos);
        if (density < 0.0f) {
            set_leaf_bit(node, cell, true);
        } 
        else {
            set_leaf_bit(node, cell, false);
        }
    }
    // Interval evaluation 
    else {
        uint mm_array[MM_ARRAY_SIZE];
        uint mm_size;
        Interval density = tape_eval_interval(tape, 
            child_pos, child_pos + params_buf.levels[LVL].cell_size,
            mm_array, mm_size);
        // Empty node
        if (density.low > 0) {
            set_leaf_bit(node, cell, false);
            set_interior_bit(node, cell, false);
            return;
        }  
        // Leaf node
        else if (density.high < 0) {
            set_leaf_bit(node, cell, true);
            set_interior_bit(node, cell, false);
        }
        // Ambiguous node
        else {
            set_leaf_bit(node, cell, false);
            set_interior_bit(node, cell, true);

            // TODO : shorten the tape

            uint child = atomicAdd(child_count_buf.child_count, 1);
            set_child_list_entry(node, cell, child);
            set_child_coords(child, child_coords);
            set_child_tape_idx(child, 0);
        }
    }  
}


// The first stage only updates the leaf and interior masks.
// All the other book-keeping operations are performed in the second stage. 
void main()
{ 
    uvec3 cell = gl_GlobalInvocationID.xyz % DIM;
    uint node = gl_GlobalInvocationID.x / DIM;
    voxelize(node, cell);
} 