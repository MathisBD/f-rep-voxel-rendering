
/*struct Affine 
{
    float c;
    // errors correlated with x, y and z.
    vec3 axis;
    // accumulated errors.
    float acc;
};

float norm_1(vec4 v)
{
    vec4 va = abs(v);
    return va.x + va.y + va.z + va.w;
}

Affine affine_multiply(Affine a, Affine b)
{
    float norm_a = norm_1(a.axis, a.acc);
    float norm_b = norm_1(b.axis, b.acc);
    return Affine(a.c * b.c, a.axis * b.c + a.c * b.axis, 
        abs(a.acc * b.c + a.c * b.acc) + norm_a * norm_b);
}

// Compute the affine representation of f(a),
// where f is approximated by :
// |f(x) - (px + q)| <= |delta| on the range of values that a can take.
Affine affine_func(Affine a, float p, float q, float delta)
{
    return Affine(q + p * a.c, p * a.axis, abs(p * a.acc) + abs(delta));
}

Affine affine_inverse(Affine a)
{
    float low = a.c - norm_1(a.axis, a.acc);
    float high = a.c + norm_1(a.axis, a.acc);

    // We use the min-range approximant on [low, high].
    float p, q, delta;
    if (low <= 0 && high >= 0) {
        p = q = 0;
        delta = infinity;
    }
    else if (low > 0) {
        p = -1 / (high*high);
        q = -p * (low + high) * (low + high) / (2 * low);
        delta = -p * (low - high) * (low - high) / (2 * low);;
    }
    else {
        p = -1 / (low*low);
        q = -p * (low + high) * (low + high) / (2 * high);
        delta = -p * (low - high) * (low - high) / (2 * low);
    }
    return affine_func(a, p, q, delta);
}

Affine affine_exp(Affine a)
{
    float low = a.c - norm_1(a.axis, a.acc);
    float high = a.c + norm_1(a.axis, a.acc);

    // We use the min-range approximant on [low, high].
    float p, q, delta;
    p = exp(low);
    q = (exp(low) + exp(high) - p * (low + high)) / 2;
    delta = (exp(high) - exp(low) - p * (high - low)) / 2;
    return affine_func(a, p, q, delta);
}*/   
