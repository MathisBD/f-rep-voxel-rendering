#version 450

// Kernel group size.
layout (local_size_x = 16, local_size_y = 16) in;


#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

// Include other files
#include "raycasting/utils.comp_header"
#include "raycasting/inputs.comp_header"


struct Hit {
    float t;
    uint voxel_id;
};


// A negative value means no intersection.
// A positive value t means the intersection point is at orig + t * dir.
float raygrid_intersect(vec3 orig, vec3 dir)
{
    vec3 invDir = 1.0f / dir;
    vec3 t_0 = (params_buf.grid_world_pos - orig) * invDir; 
    vec3 t_1 = (params_buf.grid_world_pos + params_buf.grid_world_size - orig) * invDir;
    
#define SWAP(a, b) { float tmp = a; a = b; b = tmp; }
    // We chech invDir.x < 0f rather than t_0.x > t_1.x (almost equivalent),
    // because of numerical stability issues when dir.x == 0f.
    // See the comment in raytrace() for an explanation.
    if (invDir.x < 0.0f) SWAP(t_0.x, t_1.x)
    if (invDir.y < 0.0f) SWAP(t_0.y, t_1.y)
    if (invDir.z < 0.0f) SWAP(t_0.z, t_1.z)
#undef SWAP

    float t_enter = MAX_3(t_0.x, t_0.y, t_0.z);
    float t_leave = MIN_3(t_1.x, t_1.y, t_1.z);

    // no intersection
    if (t_enter > t_leave || t_leave < 0.0f) {
        return -1.0f;
    }
    // the origin is out of the grid.
    if (t_enter > 0.0f) {
        return t_enter;
    }
    // the origin is in the grid.
    else {
        return 0.0f;
    }
}


/*bool dda(vec3 orig, vec3 dir, out Hit out_hit)
{
    vec3 normOrig = (orig - NODE_WORLD_POS(0, 0)) / CELL_SIZE(0);
    vec3 invDir = 1.0f / dir;
  
    // Differential cell/time values.
    vec3 d_t = CELL_SIZE(0) * abs(invDir);
    ivec3 d_cell = ivec3(sign(dir));
    // make sure d_cell != 0, to avoid any infite loop.
    bvec3 mask = equal(d_cell, vec3(0, 0, 0));
    d_cell += ivec3(mask);

    // Current cell/time values.
    float curr_t = 0;
    ivec3 curr_cell = ivec3(floor(normOrig));
    
    // Next crossing times.
    // For numerical stability reasons we check the sign of invDir rather than dir.
    // If e.g. dir.x == -0f, then dir.x >= 0f is true but 1f / dir.x = -inf,
    // which is not what we want (when dir.x >= 0f, we want 1f / dir.x >= 0f); 
    vec3 nextCross_t = curr_cell - normOrig;
    if (invDir.x >= 0.0f) nextCross_t.x += 1.0f;
    if (invDir.y >= 0.0f) nextCross_t.y += 1.0f;
    if (invDir.z >= 0.0f) nextCross_t.z += 1.0f;
    nextCross_t *= CELL_SIZE(0) * invDir;

    while (true) {
        // Out of grid
        if (curr_cell.x < 0 || curr_cell.x >= uniformBuffer.levels[0].dim || 
            curr_cell.y < 0 || curr_cell.y >= uniformBuffer.levels[0].dim || 
            curr_cell.z < 0 || curr_cell.z >= uniformBuffer.levels[0].dim) {
            return false;
        }

        // Is there a voxel here ?
        uint index = INDEX3D(curr_cell, uniformBuffer.levels[0].dim); 
        if (node_has_child(0, 0, index)) {
            out_hit.t = curr_t;
            out_hit.voxel_id = node_get_child(0, 0, index);
            return true;
        }

        // x
        if (nextCross_t.x <= nextCross_t.y && nextCross_t.x <= nextCross_t.z) {
            curr_t = nextCross_t.x;
            nextCross_t.x += d_t.x;
            curr_cell.x += d_cell.x;
        }   
        // y
        else if (nextCross_t.y <= nextCross_t.z) {
            curr_t = nextCross_t.y;
            nextCross_t.y += d_t.y;
            curr_cell.y += d_cell.y;
        }
        // z
        else {
            curr_t = nextCross_t.z;
            nextCross_t.z += d_t.z;
            curr_cell.z += d_cell.z;
        }
    }
}*/



bool dda(vec3 orig, vec3 dir, out Hit hit)
{
    vec3 invDir = 1.0f / dir;
    uint level = 0;

    // These are duplicated for each level.
    uint node_id[MAX_LEVEL_COUNT];
    float curr_t[MAX_LEVEL_COUNT];
    
    // These are recalculated each time we change level.
    ivec3 local_cell;
    vec3 next_t;
    
    ivec3 d_cell = ivec3(sign(dir));
    // make sure d_cell != 0, to avoid any infite loop.
    bvec3 mask = equal(d_cell, vec3(0, 0, 0));
    d_cell += ivec3(mask);


// Computes the local cell and the next crossing times.
// Typically called when we change level.
#define DDA_INIT() {                                        \
    vec3 norm_pos = (orig + (curr_t[level] + 0.001f) * dir -\
        node_world_pos(node_id[level], level)) /            \
        params_buf.levels[level].cell_size;                 \
                                                            \
    local_cell = ivec3(floor(norm_pos));                    \
                                                            \
    next_t = local_cell - norm_pos;                         \
    if (invDir.x >= 0.0f) next_t.x += 1.0f;                 \
    if (invDir.y >= 0.0f) next_t.y += 1.0f;                 \
    if (invDir.z >= 0.0f) next_t.z += 1.0f;                 \
    next_t *= params_buf.levels[level].cell_size * invDir;  \
                                                            \
    next_t += curr_t[level];                                \
}

#define DDA_STEP() {                                        \
    if (next_t.x <= next_t.y &&                             \
        next_t.x <= next_t.z) {                             \
        curr_t[level] = next_t.x;                           \
        next_t.x += abs(invDir.x) * params_buf.levels[level].cell_size;       \
        local_cell.x += d_cell.x;                           \
    }                                                       \
    else if (next_t.y <= next_t.z) {                        \
        curr_t[level] = next_t.y;                           \
        next_t.y += abs(invDir.y) * params_buf.levels[level].cell_size;       \
        local_cell.y += d_cell.y;                           \
    }                                                       \
    else {                                                  \
        curr_t[level] = next_t.z;                           \
        next_t.z += abs(invDir.z) * params_buf.levels[level].cell_size;       \
        local_cell.z += d_cell.z;                           \
    }                                                       \
}

    // Initialize for the root.
    curr_t[0] = 0;
    node_id[0] = 0;
    DDA_INIT();
  
    // Main loop.
    while (true) {
        if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
            debugPrintfEXT("level=%u   node_id=%u   local_cell=%v3d   curr_t=%.2f   next_t=%.2v3f   node pos=%.2v3f\n", 
                level, node_id[level], local_cell, curr_t[level], next_t, node_world_pos(node_id[level], level));
        }   

        while (local_cell.x < 0 || local_cell.x >= params_buf.levels[level].dim ||
               local_cell.y < 0 || local_cell.y >= params_buf.levels[level].dim ||
               local_cell.z < 0 || local_cell.z >= params_buf.levels[level].dim) 
        {
            if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
                debugPrintfEXT("out of bounds : returning\n");
            }
            return false;
            /*if (level == params_buf.level_count - 1) {
                hit.t = 0;
                hit.voxel_id = 0;
                return true;
            }
            hit.t = 0;
            hit.voxel_id = 5;
            return true;*/

            //if (level == 0) return false;
            //level--;
            //DDA_INIT();
            //DDA_STEP();
        }

        uint child_index = INDEX3D(local_cell, params_buf.levels[level].dim);
        while (node_has_child(node_id[level], level, child_index)) {
            // We hit something : return.
            if (level == params_buf.level_count - 1) {
                if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
                    debugPrintfEXT("hit a voxel : returning\n");
                }
                hit.t = curr_t[level];
                hit.voxel_id = node_get_child(node_id[level], level, child_index);
                return true;
            }
            // Otherwise recurse in the child node.
            if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
                debugPrintfEXT("hit a cell : going down\n");
            }
            node_id[level + 1] = node_get_child(node_id[level], level, child_index);
            curr_t[level + 1] = curr_t[level];
            level++;
            DDA_INIT();
            
            if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
                debugPrintfEXT("level=%u   node_id=%u   local_cell=%v3d   curr_t=%.2f   next_t=%.2v3f   node pos=%.2v3f\n", 
                    level, node_id[level], local_cell, curr_t[level], next_t, node_world_pos(node_id[level], level));
            }

            if (local_cell.x < 0 || local_cell.x >= params_buf.levels[level].dim ||
                local_cell.y < 0 || local_cell.y >= params_buf.levels[level].dim ||
                local_cell.z < 0 || local_cell.z >= params_buf.levels[level].dim) {
                
                if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
                    debugPrintfEXT("error : aborting\n");
                }

                hit.t = -1;
                return true;
            }
        
            child_index = INDEX3D(local_cell, params_buf.levels[level].dim);
        }

        DDA_STEP();
    }
}


vec4 shade(vec3 ray_orig, vec3 ray_dir, Hit hit)
{
    VoxelData voxel = voxel_buf.voxels[hit.voxel_id];
    
    vec4 diffuse = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    for (uint i = 0; i < params_buf.light_count; i++) {
        DirectionalLight light = params_buf.lights[i];
        
        // Check the light illuminates the voxel
        //vec3 shadow_ray_orig = ray_orig + (hit.t - 0.0001f) * ray_dir; 
        //Hit dummy_hit;
        //bool did_hit = dda(shadow_ray_orig, -light.direction.xyz, dummy_hit);
        //if (!did_hit) {
            // Add the light contribution
            float intensity = max(dot(-light.direction.xyz, voxel.normal), 0.0f);
            diffuse += intensity * light.color;
        //}
    }

    vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f);

    return params_buf.materials[voxel.material_idx].color * (ambient + diffuse);
}



vec4 raytrace(vec3 orig, vec3 dir)
{
    Hit hit;
    bool did_hit = dda(orig, dir, hit);
    if (did_hit) {
        // Something went wrong : show a debug color.
        if (hit.t < 0.0f) {
            return vec4(1, 1, 1, 1);
        }
        // All is good.
        return shade(orig, dir, hit);
    }
    else {
        return params_buf.background_color;
    }
}


void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;

    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
        debugPrintfEXT("\n");
    }

    if (gid.x < params_buf.screen_res.x && 
        gid.y < params_buf.screen_res.y) 
    {
        // Compute the ray direction
        float dx = 2.0f * (gid.x / float(params_buf.screen_res.x)) - 1.0f;
        float dy = 2.0f * (gid.y / float(params_buf.screen_res.y)) - 1.0f;
        vec3 dir = normalize(
            params_buf.camera_forward.xyz +
            dx * params_buf.screen_world_size.x * params_buf.camera_right.xyz +
            dy * params_buf.screen_world_size.y * params_buf.camera_up.xyz);

        float start_t = raygrid_intersect(params_buf.camera_pos.xyz, dir);
        vec4 color = params_buf.background_color;
        if (start_t >= 0.0f) {
            // Project the origin onto the grid, along the ray direction.
            vec3 projected_orig = params_buf.camera_pos.xyz + (start_t + 0.001f) * dir;
            color = raytrace(projected_orig, dir);
        }
        imageStore(out_img, ivec2(gid), color);
    }
}