
#define MAX_LIGHT_COUNT     8
#define MAX_MATERIAL_COUNT  8
#define MAX_LEVEL_COUNT     8

struct VoxelData {
    vec3 normal;
    uint material_idx;
};

struct DirectionalLight {
    vec4 color;
    vec4 direction;
};

struct Material {
    vec4 color;
};

struct LevelData {
    uint dim;
    // These are offsets in the node and child buffers.
    // They are given in uints rather than in bytes.
    uint node_ofs;
    uint child_ofs;
    // The world size of a single child cell at this level.
    // The cell_size of the last level (level_count-1) is the voxel size.
    // The cell_size of level 0 is world_size / dim[0].
    float cell_size;
};

// Output image.
layout (set = 0, binding = 0, rgba8) uniform image2D out_img;

// Shader basic data.
layout (set = 0, binding = 1) uniform ParamsBuffer {
    uint light_count;
    uint material_count;
    // The valid levels range from 0 to level_count-1 included.
    // Level 0 contains the unique root node, and level_count-1 the leaf nodes,
    // whose children are voxels.
    uint level_count;
    uint tape_instr_count;

    vec4 camera_pos;
    vec4 camera_forward;
    vec4 camera_up;
    vec4 camera_right;

    vec3 grid_world_pos;
    float grid_world_size;

    uvec2 screen_res;
    vec2 screen_world_size;

    LevelData levels[MAX_LEVEL_COUNT];

    vec4 background_color;
    DirectionalLight lights[MAX_LIGHT_COUNT]; 
    Material materials[MAX_MATERIAL_COUNT];
} params_buf;

// Nodes
// We need the std430 layout here so that the array stride is 4 bytes.
// The std14
    uint _padding_;0 layout would round it up to 16 bytes.
layout (std430, set = 0, binding = 2) readonly buffer NodeBuffer {
    uint data[];
} node_buf;

layout (std430, set = 0, binding = 3) readonly buffer ChildBuffer {
    uint data[];
} child_buf;

layout (std430, set = 0, binding = 4) readonly buffer VoxelBuffer {
    VoxelData voxels[];
} voxel_buf;

layout (std430, set = 0, binding = 5) readonly buffer TapeBuffer {
    uint data[];
} tape_buf;

// Node structure.
// Sizes are given in uints rather than bytes.
#define NODE_SIZE(level) (4 + (CUBE(params_buf.levels[(level)].dim) >> 4))
#define NODE_OFS_CL_IDX(level)  0
#define NODE_OFS_COORDS(level)  1
#define NODE_OFS_MASK(level)    4
#define NODE_OFS_MASK_PC(level) (4 + (CUBE(params_buf.levels[(level)].dim) >> 5))

// Child list structure.
// Sizes are given in uints rather than bytes.
#define CL_SIZE(level) CUBE(params_buf.levels[(level)].dim)

// Tape instruction structure.
// Sizes are in uints.
#define TAPE_INSTR_SIZE   2


// child_index == INDEX(local position in the node)
bool node_has_child(uint node_id, uint level, uint child_index)
{
    // get the node's mask position in the node buffer
    uint mask_pos = 
        params_buf.levels[level].node_ofs +
        NODE_SIZE(level) * node_id +
        NODE_OFS_MASK(level);
    
    uint q = child_index >> 5;
    uint r = child_index & 0x1F;

    uint mask = node_buf.data[mask_pos + q];
    return bool(mask & (1 << r));
}

// child_index == INDEX(local position in the node)
// Returns the node id / voxel id of the child.
uint node_get_child(uint node_id, uint level, uint child_index)
{
    // The node's position in the node buffer.
    uint node_pos = params_buf.levels[level].node_ofs +
        NODE_SIZE(level) * node_id;

    uint q = child_index >> 5;
    uint r = child_index & 0x1F;

    LOG2("q=%u   r=%u\n", q, r);

    // Compute the child's position in the child list
    uint child_pos = 0;
    LOG1("child_pos=%u\n", child_pos);
    if (q > 0) {
        child_pos += node_buf.data[node_pos + NODE_OFS_MASK_PC(level) + (q-1)];
    }
    LOG1("child_pos=%u\n", child_pos);
    if (r > 0) {
        uint mask = node_buf.data[node_pos + NODE_OFS_MASK(level) + q];
        child_pos += bitCount(mask & ((1 << r) - 1));
    }
    LOG1("child_pos=%u\n", child_pos);

    // The node's child list position in the child buffer
    uint cl_pos = params_buf.levels[level].child_ofs +
        CL_SIZE(level) * node_id;

    LOG2("child_ofs=%u   cl_size(level)=%u\n",
        params_buf.levels[level].child_ofs, CL_SIZE(level));

    LOG4("node=%u   level=%u   child_index=%u   cl_idx=%u\n",
        node_id, level, child_index, node_buf.data[node_pos]);

    return child_buf.data[cl_pos + child_pos];
}

vec3 node_world_pos(uint node_id, uint level)
{
    uint coords_pos = 
        params_buf.levels[level].node_ofs +
        NODE_SIZE(level) * node_id +
        NODE_OFS_COORDS(level);

    uvec3 coords = uvec3(
        node_buf.data[coords_pos],
        node_buf.data[coords_pos + 1],
        node_buf.data[coords_pos + 2]);

    return params_buf.grid_world_pos +
        vec3(coords) * params_buf.levels[params_buf.level_count - 1].cell_size;
}


float eval_tape(vec3 pos)
{
    float slots[MAX_SLOT_COUNT];
    slots[0] = pos.x;
    slots[1] = pos.y;
    slots[2] = pos.z;

    uint i = 0;
    while (i < params_buf.tape_instr_count) {
        uint low = tape_buf[2*i];
        uint high = tape_buf[2*i+1];
        uint op = low & 0xFFFF;
        uint outSlot = (low >> 16) & 0xFFFF;
        switch (op) {
        case OP_CONSTANT:
            float       
        } 
    }   
}