#define MAX_SLOT_COUNT      16


#define OP_CONSTANT 0
#define OP_SIN      1
#define OP_COS      2
#define OP_ADD      3
#define OP_SUB      4
#define OP_MUL      5
#define OP_DIV      6

float eval_tape(vec3 pos)
{
    LOG1("POS=%.2v3f\n", pos);

    float slots[MAX_SLOT_COUNT];
    slots[0] = pos.x;
    slots[1] = pos.y;
    slots[2] = pos.z;

    uint i = 0;
    while (i < params_buf.tape_instr_count) {
        // Decode the instruction
        uint inst = tape_buf.instrs[i];
        uint op      = (inst >> 0)  & 0xFF;
        uint outSlot = (inst >> 8)  & 0xFF;
        uint inSlotA = (inst >> 16) & 0xFF;
        uint inSlotB = (inst >> 24) & 0xFF;
        
        LOG5("i=%u   op=%u   outSlot=%u   inSlotA=%u   inSlotB=%u\n", 
            i, op, outSlot, inSlotA, inSlotB);

        // Dispatch        
        switch (op) {
        case OP_CONSTANT:
            slots[outSlot] = params_buf.const_pool[inSlotA / 4][inSlotA % 4];
            LOG1("\tCONSTANT=%.3f\n", slots[outSlot]);
            break;
        case OP_SIN:
            slots[outSlot] = sin(slots[inSlotA]);
            break;
        case OP_COS:
            slots[outSlot] = cos(slots[inSlotA]);       
            break;
        case OP_ADD:
            slots[outSlot] = slots[inSlotA] + slots[inSlotB];
            break;
        case OP_SUB:
            slots[outSlot] = slots[inSlotA] - slots[inSlotB];
            break;
        case OP_MUL:
            slots[outSlot] = slots[inSlotA] * slots[inSlotB];
            break;
        case OP_DIV:
            slots[outSlot] = slots[inSlotA] / slots[inSlotB];
            break;
        } 
        i++;
    }   
    LOG1("result=%.3f\n", slots[0]);
    return slots[0];
}