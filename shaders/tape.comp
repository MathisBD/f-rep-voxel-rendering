#define MAX_SLOT_COUNT      16


#define OP_CONSTANT 0
#define OP_SIN      1
#define OP_COS      2
#define OP_ADD      3
#define OP_SUB      4
#define OP_MUL      5
#define OP_DIV      6
#define OP_MIN      7
#define OP_MAX      8
#define OP_EXP      9
#define OP_NEG      10
#define OP_SQRT     11
#define OP_COPY     12

const float infinity = 1. / 0.;
const float pi = 3.141592653589793238462643383279502884197;

struct Interval {
    float low;
    float high;
};


float tape_eval_point(vec3 pos)
{
    float slots[MAX_SLOT_COUNT];
    slots[0] = pos.x;
    slots[1] = pos.y;
    slots[2] = pos.z;

    uint i = 0;
    while (i < params_buf.tape_instr_count) {
        // Decode the instruction
        uint inst = tape_buf.instrs[i];
        uint op      = (inst >> 0)  & 0xFF;
        uint outSlot = (inst >> 8)  & 0xFF;
        uint inSlotA = (inst >> 16) & 0xFF;
        uint inSlotB = (inst >> 24) & 0xFF;

        // Dispatch        
        switch (op) {
        case OP_CONSTANT:
            slots[outSlot] = params_buf.const_pool[inSlotA / 4][inSlotA % 4];
            break;
        case OP_SIN:
            slots[outSlot] = sin(slots[inSlotA]);
            break;
        case OP_COS:
            slots[outSlot] = cos(slots[inSlotA]);       
            break;
        case OP_ADD:
            slots[outSlot] = slots[inSlotA] + slots[inSlotB];
            break;
        case OP_SUB:
            slots[outSlot] = slots[inSlotA] - slots[inSlotB];
            break;
        case OP_MUL:
            slots[outSlot] = slots[inSlotA] * slots[inSlotB];
            break;
        case OP_DIV:
            slots[outSlot] = slots[inSlotA] / slots[inSlotB];
            break;
        case OP_MIN:
            slots[outSlot] = min(slots[inSlotA], slots[inSlotB]);       
            break;
        case OP_MAX:
            slots[outSlot] = max(slots[inSlotA], slots[inSlotB]);       
            break;
        case OP_EXP:
            slots[outSlot] = exp(slots[inSlotA]);       
            break;
        case OP_NEG:
            slots[outSlot] = -slots[inSlotA];       
            break;
        case OP_SQRT:
            slots[outSlot] = sqrt(slots[inSlotA]);       
            break;
        case OP_COPY:
            slots[outSlot] = slots[inSlotA];       
            break;
        } 
        i++;
    }   
    return slots[0];
}

Interval interval_multiply(Interval a, Interval b)
{
    Interval c;
    c.low = MIN_4(
        a.low * b.low, a.low * b.high, a.high * b.low, a.high * b.high);
    c.high = MAX_4(
        a.low * b.low, a.low * b.high, a.high * b.low, a.high * b.high);
    return c;
}

// Returns true if an integral multiple of x lies
// in the interval i (endpoints included).
bool contains_multiple(Interval i, float x)
{
    return floor(i.low / x) < floor(i.high / x) || 
           floor(i.low / x) == i.low / x        ||
           floor(i.high / x) == i.high / x;
}


Interval tape_eval_interval(vec3 low, vec3 high)
{
    Interval slots[MAX_SLOT_COUNT];
    slots[0] = Interval(low.x, high.x);
    slots[1] = Interval(low.y, high.y);
    slots[2] = Interval(low.z, high.z);

    uint i = 0;
    while (i < params_buf.tape_instr_count) {
        // Decode the instruction
        uint inst = tape_buf.instrs[i];
        uint op      = (inst >> 0)  & 0xFF;
        uint outSlot = (inst >> 8)  & 0xFF;
        uint inSlotA = (inst >> 16) & 0xFF;
        uint inSlotB = (inst >> 24) & 0xFF;

        Interval a = slots[inSlotA];
        Interval b = slots[inSlotB];

        // Dispatch        
        switch (op) {
        case OP_CONSTANT:
            float c = params_buf.const_pool[inSlotA / 4][inSlotA % 4];
            slots[outSlot] = Interval(c, c);
            break;
        case OP_COS:
            if (contains_multiple(Interval(a.low - pi, a.high - pi), 2*pi)) {
                slots[outSlot].low = -1;
            }
            else {
                slots[outSlot].low = min(cos(a.low), cos(a.high));
            }
            if (contains_multiple(a, 2*pi)) {
                slots[outSlot].high = 1;
            }
            else {
                slots[outSlot].high = max(cos(a.low), cos(a.high));
            }
            break;
        case OP_SIN:
            if (contains_multiple(Interval(a.low + pi / 2, a.high + pi / 2), 2*pi)) {
                slots[outSlot].low = -1;
            }
            else {
                slots[outSlot].low = min(sin(a.low), sin(a.high));
            }
            if (contains_multiple(Interval(a.low - pi / 2, a.high - pi / 2), 2*pi)) {
                slots[outSlot].high = 1;
            }
            else {
                slots[outSlot].high = max(sin(a.low), sin(a.high));
            }
            break;
        case OP_ADD:
            slots[outSlot] = Interval(a.low + b.low, a.high + b.high);
            break;
        case OP_SUB:
            slots[outSlot] = Interval(a.low - b.high, a.high - b.low);
            break;
        case OP_MUL:
            slots[outSlot] = interval_multiply(a, b);
            break;
        case OP_DIV:
            if ((b.low == 0 && b.high == 0) || (b.low < 0 && b.high > 0)) {
                slots[outSlot] = Interval(-infinity, infinity);
            }
            else if (b.low == 0) {
                slots[outSlot] = interval_multiply(a, Interval(1. / b.high, infinity));
            }
            else if (b.high == 0) {
                slots[outSlot] = interval_multiply(a, Interval(-infinity, 1. / b.low));
            }
            else {
                slots[outSlot] = interval_multiply(a, Interval(1. / b.high, 1. / b.low));
            }
            break;
        case OP_MIN:
            slots[outSlot] = Interval(min(a.low, b.low), min(a.high, b.high));
            break;
        case OP_MAX:
            slots[outSlot] = Interval(max(a.low, b.low), max(a.high, b.high));
            break;
        case OP_EXP:
            slots[outSlot] = Interval(exp(a.low), exp(a.high));
            break;
        case OP_NEG:
            slots[outSlot] = Interval(-a.high, -a.low);
            break;
        case OP_SQRT:
            slots[outSlot] = Interval(sqrt(max(0, a.low)), sqrt(max(0, a.high)));
            break;
        case OP_COPY:
            slots[outSlot] = a;
            break;
        } 
        i++;
    }   
    return slots[0];
}